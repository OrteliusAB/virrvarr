(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{374:function(t,e,n){"use strict";n.r(e);var a=n(25),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"imploding-and-exploding"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#imploding-and-exploding"}},[t._v("#")]),t._v(" Imploding and Exploding")]),t._v(" "),n("p",[t._v("Imploding a node is similar to applying a filter, but works a bit differently. An implosion/explosion always has a start node as well as a path of traversal. Anything that gets traversed will be will be toggled as hidden or shown. It is important to note that implosions and explosions operates only on live data, and is not aware of the existance of filtered data.")]),t._v(" "),n("p",[t._v("Nodes that are imploded will by default cause a number badge to pop up on exploded nodes that connect to them in the to-direction. Showing the user that something is currently imploded.")]),t._v(" "),n("p",[t._v("This functionality is useful if you want to allow the user to expand and collapse sections the live graph.")]),t._v(" "),n("p",[t._v("There are four different functions you can use for this:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("implodeOrExplodeNode(nodeID)")]),t._v(" "),n("ul",[n("li",[t._v("Implodes/Explodes nodes directly connected to the given node ID (in the TO direction)")])])]),t._v(" "),n("li",[n("code",[t._v("implodeOrExplodeNodeLeafs(nodeID)")]),t._v(" "),n("ul",[n("li",[t._v("Implodes/Explodes nodes directly connected to the given node ID (in the TO direction), but only if the nodes do not branch out any further (i.e. have any TO connections of their own)")])])]),t._v(" "),n("li",[n("code",[t._v("implodeOrExplodeNodeNonCircular(nodeID)")]),t._v(" "),n("ul",[n("li",[t._v("Implodes/Explodes nodes directly connected to the given node ID (in the TO direction), and then recursively continues until it finds the end of the tree")])])]),t._v(" "),n("li",[n("code",[t._v("implodeOrExplodeNodeRecursive(nodeID)")]),t._v(" "),n("ul",[n("li",[t._v("Works very similarly to recursive, but only affects node paths that have no path back to the origin node")])])])]),t._v(" "),n("p",[t._v("All four functions take two arguments, an id and a boolean to say if it is an implode operation (true) or an explode operation (false)")]),t._v(" "),n("p",[t._v("Consider the following example:")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Set the graph filters")]),t._v("\ngraph"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("implodeOrExplodeNode")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"N1"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Implode all connected nodes in the TO direction")]),t._v("\ngraph"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("implodeOrExplodeNodeLeafs")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"N1"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Explode all leafs")]),t._v("\ngraph"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("implodeOrExplodeNodeNonCircular")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"N1"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Implode nodes on isolated branches")]),t._v("\ngraph"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("implodeOrExplodeNodeRecursive")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"N1"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Explode all outwards branches recursively")]),t._v("\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);